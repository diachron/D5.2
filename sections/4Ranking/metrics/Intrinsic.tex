%!TEX root = ../../../diachron-D5_2.tex

\subsubsection{Intrinsic Category}

The intrinsic category metrics are independent of the user's context.
They reflect whether information presented in data correctly represent the real world and whether information is logically consistent itself.
\label{sec:Intrinsic} 


\subsubsection{Accuracy} % dimension name 

\paragraph{Malformed Datatype Literals} ~\\ %metric name
% background for the metric
% short description

Literals are nodes in an RDF graph, used to identify values such as numbers and dates.
A plain literal is a string combined with an optional language tag.
A typed literal comprises a string (the lexical form of the literal) and a datatype (identified by a URI) which is supposed to denote a mapping from lexical forms to some space of values.
The RDF specifies two types of literals: plain and typed. 
In the Turtle syntax typed literals are notated with syntax such as:  \textit{"13"^^xsd:int}.
Malformed datatype literals are quit common and can be fixed by simple changes to the literals.
This Malformed Datatype Literals metric intends to check if the value of a typed literal is valid with regards to the given xsd datatype.

\begin{mdframed}[style=metricdefinition]
\emph{Calculates the ratio of typed literals not valid regarding its given xsd datatype to all literals}
\end{mdframed}

% pseudocode


\begin{algorithm}
\caption{Malformed Datatype Literals Algorithm}\label{lst:deref}
\begin{algorithmic}[1]
\Procedure{init}{}
\State totalLiterals = 0 ;
\State malformedLiterals = 0 ;
\EndProcedure

\Procedure{ComputeMalformedDatatypeLiterals}{$\langle?s,?p,?o,?g\rangle$}
\If {(isLiteral(?o))} totalLiterals++ ;
\If {(isTypedLiteral(?o)) \&\& (!hasValidDatatype(?o))} malformedLiterals++ ; \EndIf
 \EndIf
\State metric=malformedLiterals/totalLiterals;
\EndProcedure
\end{algorithmic}
\end{algorithm}
% metric value, range and rating

\paragraph{Literals Incompartible with Datatype Range} ~\\ 

\paragraph{Defined Ontology Author} ~\\ 
\paragraph{POBO Definition Usage}~\\ 
\paragraph{Synonym Usage}~\\ 
\subsubsection{Consistency}~\\ 
\

\paragraph{Entities As Members of Disjoint Classes}~\\


\paragraph{Homogeneous Datatypes}~\\
 
\paragraph{Misplaced Classes or Properties}
\paragraph{Misused Owl Datatype or Object Properties}
\paragraph{Obsolete Concepts in Ontology}
\paragraph{Ontology Hijacking}
\paragraph{Undefined Classes Metric} ~\\ 
\label{par:undefClass}

Oftentimes a terms which is used in the object position of a triple and is not a literal is not formaly defined as being a class.
'Being defined' means that the term is defined either in some external ontology or at an earlier position in the given dataset. 
Regarding to Hogar ~\cite{hogan2010} to the most used undefined classes belong \texttt{foaf:UserGroup}, \texttt{rss:item}, \texttt{linkedct:link}, \texttt{politico:Term} .
The probability for undefined class in the subject position is very low, because the subject of a quad never references classes or properties in external vocabularies.
Therefore they is no need to analyse the subject for this metric.
For the most LOD data sets is sufficient to check object by the predicate \texttt{rdf:type}. 
In the case when LOD data set defines its own vocabulary the following predicates indicate that the object must be a defined class:  \texttt{rdfs:domain}, \texttt{rdfs:range}, \texttt{rdfs:subClassOf}, \texttt{owl:allValuesFrom}, \texttt{owl:someValuesFrom}, \texttt{owl:equivalentClass}, \texttt{owl:complementOf}, \texttt{owl:onClass}, \texttt{owl:disjointWith}.
The undefined classes problem occurs due to spelling or syntactic mistakes resolvable through minor fixes to the respective ontologies.
The missing classes should be define in corresponding ontology or in a separate namenspace.


\begin{mdframed}[style=metricdefinition]
\emph{Calculates the ratio of undefined classes to all classes in object position in a dataset}
\end{mdframed}


\begin{algorithm}
\caption{Undefined Classes Metric Algorithm}\label{lst:undefCl}
\begin{algorithmic}[1]
\Procedure{init}{}
\State totalClasses = 0 ;
\State undefinedClasses = 0 ;
\EndProcedure

\Procedure{ClassNotDefined}{$\langle?s,?p,?o,?g\rangle$}
\If {(isClassProperty(?p) \&\& (isURI(?o))} ; 

\If {(!isDefined(?o))  undefinedClasses++ }; \EndIf
\EndIf
\State totalClasses++ ++;
\EndProcedure
\end{algorithmic}
\end{algorithm}

\paragraph{Undefined  Properties}  ~\\ 


Similar to the Undefined Classes metric \ref{par:undefClass} the Undefined Properties metric identifies terms in the predicate position that are used without any formal definition.
 Hogan  ~\cite{hogan2010} identified the following properties that are often used whithout being defined:  \textit{foaf:image}, \textit{cycann:label} , \textit{foaf:tagLine}.
The following list of predicates indicate that the object of the quad must be a defined property:\textit{rdfs:subPropertyOf}, \textit{owl:onProperty}, \textit{owl:assertionProperty}, \textit{owl:equivalentProperty}, \textit{owl:propertyDisjointWith}.

\begin{mdframed}[style=metricdefinition]
\emph{Calculates the ratio of undefined properties to all properties in the given data set}
\end{mdframed}

\begin{algorithm}
\caption{Undefined Properties Algorithm}\label{lst:undefCl}
\begin{algorithmic}[1]
\Procedure{init}{}
\State totalProperties = 0 ;
\State undefinedProperties = 0 ;
\EndProcedure

\Procedure{PropertyNotDefined}{$\langle?s,?p,?o,?g\rangle$}
\If {(isURI(?p) totalProperties++} ; 
\If {(!isDefined(?p)) udefinedProperties++ }; \EndIf

\If {(isFromList(?p)) \&\&  !isDefined(?o) udefinedProperties++ }; \EndIf
\State totalProperties ++;
\EndIf

\EndProcedure
\end{algorithmic}
\end{algorithm}


\subsubsection{Conciseness}

\paragraph{Duplicate Instance}

\paragraph{Extensional Conciseness}

\paragraph{Ontology Versioning Conciseness}



